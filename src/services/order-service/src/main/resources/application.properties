# Eureka Service Name üzerinden ba?lan?r
spring.application.name=order-service
server.port= 5003

# DB Settings
spring.datasource.url=jdbc:h2:mem:ddd_db;
spring.datasource.username=sa
spring.datasource.password=password
spring.datasource.driver-class-name=org.h2.Driver

# H2 Database Settings
spring.h2.console.path=/h2-console
spring.h2.console.enabled=true

# JPA Hibernate Setting
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=create
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect


# Spring Boot Admin Client Settings
spring.boot.admin.client.url = http://localhost:5050
spring.boot.admin.client.instance.service-url = http://localhost:5003
spring.boot.admin.client.username = admin
spring.boot.admin.client.password = P@ssword1


# Eureka Client Settings
eureka.client.enabled=true
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
eureka.client.service-url.defaultZone= http://localhost:8761/eureka

# Circuit Braker Settings

# sa?l?k bilgilerini actuator ile payla?s?n
resilience4j.circuitbreaker.instances.productClient.register-health-indicator=true
resilience4j.circuitbreaker.instances.productClient.sliding-window-size=5
# yüzde kaç ba?ar?s?zl??a ula??nca circuit braker çal?ss?n
resilience4j.circuitbreaker.instances.productClient.failure-rate-threshold=50
# istekleri 5 saniye boyunca kesintiye u?rat
resilience4j.circuitbreaker.instances.productClient.wait-duration-in-open-state=10s
# kaç hatal? ça?r?dan sonra devreye girer
resilience4j.circuitbreaker.instances.productClient.minimum-number-of-calls=3

# Not: kar?? client herhangi bir runtime hatas?nda devreye girer ama öncesinde action üstüne @CircuiteBraker tan?m? yap?lmal?d?r.


# Retry settings
# ilk istek dahil ilk istek sonras? 3 kez daha dene
resilience4j.retry.instances.productClient.max-attempts= 4
resilience4j.retry.instances.productClient.wait-duration.=1s


# Ratelimitter Settings -> Endpoint bazl? ça??r?larak, ne kadar süre için endpoint max istek say?s? s?n?rland?r?l?r.
resilience4j.ratelimiter.instances.productClient.timeout-duration=1s
resilience4j.ratelimiter.instances.productClient.limit-for-period=5
resilience4j.ratelimiter.instances.productClient.limit-refresh-period=60s



# Spring Cloud Stream Kafka
# Consumer olarak tetiklenecek olan function
spring.cloud.function.definition=sample;sample01;sample_error
# Kafka Broker
spring.cloud.stream.kafka.binder.brokers=localhost:29092
# binding tanimlarindaki topicler için partition say?s? kadar otomatik partion olu?tur.
spring.cloud.stream.kafka.binder.auto-create-topics=true

# Partitionlar? otomatik ekle
spring.cloud.stream.kafka.binder.auto-add-partitions: true
# keylerin serializer ayar?
spring.cloud.stream.kafka.binder.configuration.key.serializer: org.apache.kafka.common.serialization.StringSerializer


# Out -> Sample topic veriyi bind et
spring.cloud.stream.bindings.sample-out-0.destination=sample_topic
spring.cloud.stream.bindings.sample-out-0.producer.partition-count=5

# keyden mesajlar?n ayn? partition seçimi yapmas? için tanimladik.
spring.cloud.stream.kafka.bindings.sample-out-0.producer.message-key-expression=headers['correlationId']


# In -> fanout
# Mesaj?n iletimesi için max 3 kere dene
spring.cloud.stream.bindings.sample-in-0.destination=sample_topic
spring.cloud.stream.bindings.sample-in-0.group=sample_group
spring.cloud.stream.bindings.sample-in-0.consumer.max-attempts=3

# Consumer Dead letter queue aktif hale geldi
spring.cloud.stream.kafka.bindings.sample-in-0.consumer.enable-dlq=true

# DLQ hatalar? topiclere at?lmas? için consumer mesaj? ald?ktan sonra bir runtime exception durumunun olu?mas?
# laz?m
# DLQ producer kaynakl? hatalar ile ilgilenmez.

# hatal? mesajlar bu topicde toplans?n
spring.cloud.stream.kafka.bindings.sample-in-0.consumer.dlq-name=sample_dlq_topic
# mesaj?n i?lenmedi?ini daha sonras?nda i?lenece?ini ayarlad???m?z
spring.cloud.stream.kafka.bindings.sample-in-0.consumer.auto-commit-on-error=false


#Dlq Consumer
spring.cloud.stream.bindings.sample_error-in-0.destination=sample_dlq_topic
spring.cloud.stream.bindings.sample_error-in-0.group=sample_group





# Not: Producer k?sm?nda e?er kafka 2.x versiyonu kullan?yorsak -> mesajlar? göndermeyi denerken hata al?rsa
# ayn? producerId ile devam etmez bu durumda farkl? mesaj gibi alg?lanabilir.

spring.cloud.stream.kafka.bindings.sample-out-0.producer.configuration.enable.idompetance=true
# tüm follower ve leader partionlarda hepsinin replice olmas?n? bekle. -> bir mesaj?n commit olmas? için
# tüm leader followerlarda olu?mas? laz?m.
spring.cloud.stream.kafka.bindings.sample-out-0.producer.configuration.acks=all
# Default 3 -> kafka broker ba?lant?s? koparsa kaç kez arka arkaya göndermeyi denesin
spring.cloud.stream.kafka.bindings.sample-out-0.producer.configuration.retries=5


# In Senaryo Ayn? Topic Ayn? Group Id -> Point to Point
#spring.cloud.stream.bindings.sample01-in-0.destination=sample_topic
#spring.cloud.stream.bindings.sample01-in-0.group=sample_group


# In (Ayn? binding ismi veremeyiz) -> fanout
#spring.cloud.stream.bindings.sample01-in-0.destination=sample_topic
#spring.cloud.stream.bindings.sample01-in-0.group=sample_group_01

# Not: ayn? topic farkl? group mesaj?n çoklanmas? senaryosu.


management.tracing.sampling.probability= 1.0
management.zipkin.tracing.endpoint= http://localhost:9411/api/v2/spans


logging.config=classpath:spring_logback.xml














